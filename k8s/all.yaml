apiVersion: v1
kind: List
items:
- apiVersion: v1
  kind: Service
  metadata:
    labels:
      qcloud-app: xxx-server  # 与下方服务名称保持一致就可以，这是定义了一组label，方便后续查找
    name: xxx-server    # 服务名称
    namespace: server-universal  # 这个需要预创建，部署服务到哪个命名空间下，跟编程语言内涵一致，一般情况下，是以项目产品线区分，除非是通用公共服务，比如auth、passport这类是在server-universal
  spec:
    ports: # 这是个数组，有多少端口需要暴露就有多个声明
    - nodePort: 30255  # 如果需要集群外访问此服务，就需要暴露nodePort，硬性规定只能30000-32267之间，集群内唯一，外部访问以集群内任一主机节点IP:nodePort形式访问
      name: 50052tcp30255 # 不是必须的，但如果以kubectl create形式创建就需要，而用kubectl apply就不需要
      protocol: TCP # 协议号
      port: 50052 # Service在集群内有一个IP-ClusterIP，集群内服务可以用ClusterIP:port形式访问本服务，但是更加优雅的做法是利用K8S服务发现，只需要使用service-name.namespace.svc.cluster.local:port就可以访问，无需IP
      targetPort: 50052 # 对应Pod内容器端口
    - nodePort: 30250
      name: 7001tcp30250
      protocol: TCP
      port: 7001
      targetPort: 7001
    selector:
      qcloud-app: xxx-server # 这个是告诉Service我该如何把流量导给哪些服务，满足label条件:qcloud-app=xxx-server
    sessionAffinity: None
    type: NodePort  # Service的类型决定了访问形式，主要有4种，需要集群外访问就要Node Port，需要带URL路径匹配就需要LoabBalancer，如果前两个要求都满足需要Ingress，只在集群内访问就ClusterIP
- apiVersion: extensions/v1beta1
  kind: Deployment # 以无状态应用模式部署，常用的还有DaemonSet(每种Node都部署)、StatefulSet(有状态应用，这类比较复杂，不再赘述)、CronJob(集群内定时任务)、Job(一次性任务，比较适合迁移数据、升级)
  metadata:
    annotations:
      description: xxx-server # 描述而已，方便控制台查看
    labels:
      qcloud-app: auth-server #  这是Deployment的label
    name: xxx-server  # 这是Deployment的名称
    namespace: server-universal # Deployment所属的命名空间
  spec:
    minReadySeconds: 10  #最短10s的ready时间，不要因为10s没有就绪就认为启动失败，然后crashbackoff
    replicas: 1 # 实例数目
    revisionHistoryLimit: 5 # K8S帮你保存的版本数，1-5之内都可以，一般来说不要超过5，占空间，可以快速回滚
    selector:
      matchLabels:
        qcloud-app: xxx-server # 这是关键，与下方template的metadata中labels对应
    strategy: # 升级策略
      rollingUpdate:
        maxSurge: 1 #最大溢出值，一般般说来升级过程出现的最多pod数目 = maxSurge+replicas
        maxUnavailable: 0 # 这就意味着升级过程中永远都有replicas数目的服务提供服务
      type: RollingUpdate # 滚动升级，还有其他几种升级方式，Rollout等
    template:
      metadata:
        labels:
          qcloud-app: auth-server # 这是关键，与Service的selector对应
      spec:
        containers: # 这是数组，所以一个POD里面可以放多个容器
        - image: ccr.ccs.tencentyun.com/quqi/xxxx:yyyyy #镜像名称
          env:
          - name: EGG_SERVER_ENV # 容器启动参数
            value: prod
          imagePullPolicy: IfNotPresent # 镜像拉取策略
          name: xxx-server  #容器名称
          livenessProbe: # 存活健康检查，k8s决定容器存活依据之一
            failureThreshold: 3 # 最多允许连续3次失败，失败超过3次按杀死处理
            httpGet:
              path: /api/auth/healthCheck
              port: 7001
              scheme: HTTP
            initialDelaySeconds: 10 # 前10s内不做存活检查
            periodSeconds: 5 # 多长时间发起一次，这个是要权衡考量的值
            successThreshold: 1 # 失败之后连续多少次成功算作存活
            timeoutSeconds: 2 # 延时
          ports:  #容器暴露端口
          - containerPort: 50052
            protocol: TCP
          - containerPort: 7001
            protocol: TCP
          readinessProbe: # 就绪检查，这是服务开始提供工作的依据，跟存活检查类似的参数
            failureThreshold: 3
            httpGet:
              path: /api/auth/healthCheck
              port: 7001
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 5
            successThreshold: 2
            timeoutSeconds: 2
          securityContext: # 这是容器的安全设置，与Docker一致，建议直接查看Docker相关文档
            allowPrivilegeEscalation: false
            privileged: false #是否特权级容器
            readOnlyRootFilesystem: false 
            runAsNonRoot: false 
          stdin: true # 需不需要从stdin获取信息，否则获得的都是EOF，这个要跟TTY配合一起用
          terminationMessagePath: /dev/termination-log #容器终止信息写在容器里面哪个路径下面
          terminationMessagePolicy: File # 容器终止信息写入文件
          tty: true # 为容器分配TTY，如果你想用连接至容器内部就必须分配
          resources: # 资源使用申请和限制
            requests: # 申请用多少 内存是独占资源，不能共享，CPU是共享资源
              memory: "1024Mi"  # 内存占用
              cpu: "1000m" # m是milli 千分之一的意思，一般小于1的内涵反映的是占用单核CPU的使用率，大于1反映的是多核的使用量，这是个绝对值，无论是单核、还是多核，内涵一致
            limits: # 最多用多少
              memory: "2048Mi"
              cpu: "3200m"
        dnsPolicy: ClusterFirst #DN，S查询的优先级原则如果要依赖k8S服务发现的化，必须设置ClusterFirst
        imagePullSecrets: #镜像拉取秘钥，这关系到能不能去私有仓库拉取镜像
        - name: qcloudregistrykey
        - name: tencenthubkey
        restartPolicy: Always # 容器重启策略，如果启动失败就继续重启，直至重启就绪检查成功
        securityContext: {} # 这是pod的安全设置，与容器不一致
        serviceAccountName: "" # serviceaccount需要预设，这是k8s内部服务之间访问的令牌，默认是不用任何令牌
        terminationGracePeriodSeconds: 30 #30s内优雅退出，可选项，30s内如果不退出按退出失败处理，另开新容器，直接杀死旧容器
        volumes: null # 是否挂载数据卷
